<html>
<body>
<h1> Test Avito </h1>
<script>
alert(document.cookie);
alert(localStorage.length);
(function enumerateAppInterface() {
  const name = "appInterface";
  if (!(name in window)) {
    return { error: `${name} not found on window` };
  }

  const obj = window[name];
  const seen = new Set();
  const props = [];

  function safePush(p) {
    if (!seen.has(p)) { seen.add(p); props.push(p); }
  }

  // 1) own property names
  try { Object.getOwnPropertyNames(obj).forEach(safePush); } catch(e){ /*ignore*/ }
  // 2) own symbol keys
  try { Object.getOwnPropertySymbols(obj).forEach(s => safePush(String(s))); } catch(e){ }
  // 3) Reflect.ownKeys
  try { Reflect.ownKeys(obj).forEach(k => safePush(String(k))); } catch(e){ }
  // 4) for..in (enumerable)
  try { for (let k in obj) safePush(k); } catch(e){ }
  // 5) iterate prototype chain properties (some host objects put methods on prototype)
  try {
    let p = Object.getPrototypeOf(obj);
    let depth = 0;
    while (p && p !== Object.prototype && depth++ < 10) {
      try { Object.getOwnPropertyNames(p).forEach(n => safePush(n + " (proto)")); } catch(e){}
      p = Object.getPrototypeOf(p);
    }
  } catch(e){}

  const report = {};
  props.forEach(k => {
    const entry = { name: k, accessible: true, type: null, isFunction: false, nativeLike: false, readError: null };
    try {
      let key = k;
      let isProto = false;
      if (k.endsWith(" (proto)")) { key = k.replace(/ \(proto\)$/, ""); isProto = true; }
      // access via try/catch
      let val;
      try {
        val = obj[key];
      } catch(e) {
        entry.accessible = false;
        entry.readError = String(e);
        report[k] = entry;
        return;
      }
      entry.type = typeof val;
      if (entry.type === "function") {
        entry.isFunction = true;
        try {
          const s = Function.prototype.toString.call(val);
          entry.nativeLike = /\[native code\]/.test(s) || /function\s*\(\)\s*\{\s*\[native code\]\s*\}/.test(s);
          entry.signature = s.length > 200 ? s.slice(0,200) + "â€¦" : s;
        } catch(e) {
          // some host methods throw when toString'd
          entry.signature = String(val);
        }
      } else {
        // for non-functions, small sample of value (avoid huge blobs)
        try {
          if (val === null) entry.valueSample = null;
          else if (typeof val === "object") {
            entry.valueSample = Object.prototype.toString.call(val);
          } else {
            entry.valueSample = String(val).slice(0,200);
          }
        } catch(e) {
          entry.valueSample = "unreadable: " + String(e);
        }
      }
    } catch(e) {
      entry.readError = String(e);
    }
    report[k] = entry;
  });

  // Extra: list names that might be sensitive (heuristic)
  const suspicious = Object.keys(report).filter(n => {
    const ln = n.toLowerCase();
    return ln.includes("exec") || ln.includes("run") || ln.includes("open") || ln.includes("file")
        || ln.includes("cmd") || ln.includes("send") || ln.includes("sms") || ln.includes("call")
        || ln.includes("download") || ln.includes("delete") || ln.includes("copy") || ln.includes("save");
  });

  return { interfaceName: name, foundProps: props.length, propsReport: report, suspiciousNames: suspicious };
})();
</script>
</body>
</html>
